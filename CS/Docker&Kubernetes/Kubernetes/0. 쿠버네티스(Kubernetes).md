# 0. 쿠버네티스(Kubernetes)

### 컨테이너 변화과정

<img src="https://user-images.githubusercontent.com/33214969/161390909-392ce647-285b-41f9-b7f2-9f7e799ac5af.png" alt="container_evolution.png" width="100%;" />

+ 전통적인 배포
  + 여러 개의 애플리케이션을 하나의 물리 서버에서 실행 → 리소스 할당 문제 발생
+ 가상화 배포
  + 단일 물리 서버의 CPU에서 여러 가상 시스템(VM)을 실행
  + 가상화 사용 → VM간 애플리케이션을 격리 → 애플리케이션 간 액세스가 어려움 → 일정 수준의 보안성을 제공함
  + 가상화 사용 → 리소스를 보다 효율적으로 활용할 수 있음 + 쉽게 애플리케이션 추가/업데이트가 가능 + 하드웨어 비용 절감
  + 가상화를 통해 일련의 물리 리소스를 폐기 가능한(disposable) 가상 머신으로 구성된 클러스터로 만들 수 있음
  + VM = 가상화된 하드웨어 상에서 자체 OS를 포함한 모든 구성 요소를 실행하는 하나의 완전한 머신
+ 컨테이너 배포
  + VM과 유사하지만 격리 속성을 완화하여 애플리케이션 간 OS를 공유함
  + VM과 마찬가지로 컨테이너에는 자체 파일 시스템, CPU 점유율, 메모리, 프로세스 공간 등이 있음
  + 기본 인프라와의 종속성을 끊었기 때문에 클라우드 or OS 배포본에 모두 이실할 수 있음
  + 컨테이너 혜택
    + 기민한 애플리케이션 생성 & 배포<br/> - 컨테이너 이미지 생성이 보다 쉽고 효율적임
    + 지속적인 개발, 통합 및 배포<br/> - 안정적&주기적으로 컨테이너 이미지를 빌드+배포 가능함<br/> - (이미지의 불변성 덕분에) 빠르고 효율적으로 롤백 가능함
    + 개발과 운영의 관심사 분리<br/> - 배포 시점이 아닌 빌드/릴리즈 시점에 애플리케이션 컨테이너 이미지를 만들기 대문에 애플리케이션이 인프라 스트럭처에서 분리됨
    + 가시성(Observability)<br/> - OS 수준의 정보와 메트릭(metrics)에 머무르지 않고, 애플리케이션의 헬스(health)와 그 밖의 시그널을 볼 수 있음
    + 개발, 테스트 및  운영 환경에 걸친 일관성<br/> - 랩탑(laptop)에서도 클라우드에서와 동일하게 구동됨
    + 클라우드 및 OS 배포판 간 이식성<br/> - 우분투, RHEL, CoreOS, on-premises, 주요 public 클라우드와 어디에서든 구동됨
    + 애플리케이션 중심 관리<br/> - 가상 하드웨어 상에서 OS를 실행하는 수준에서 → 논리적인 리소스를 사용하는 OS 상에서 애플리케이션을 실행하는 수준으로 추상화 수준이 높아짐
    + 느슨한 커플(couple), 분산(distributed), 유연(elastic), 자유로운(liberated) 마이크로서비스<br/> - 애플리케이션은 단일 목적의 머신에서 모놀로식 스택(monolithic stack)으로 구동되지 않고, 보다 작고 독립적인 단위로 쪼개져서 동적으로 배포+관리될 수 있음
    + 리소스 격리<br/> - 애플리케이션 성능 예측이 가능함
    + 리소스 사용량<br/> - 고효율, 고밀eh

<br/>

## 쿠버네티스(Kubernetes)

```tex
▫️ 컨테이너화된 워크로드와 서비스를 관리하기 위한 이식성이 있고, 확장 가능한 오픈소스 플랫폼
```

+ 특징
  + K8s = “K”와 “s” 그 사이에 있는 8글자를 나타내는 약식 표기<br/> - 쿠버네티스는 분산 시스템을 탄력적으로 실행하기 위한 프레임워크를 제공함 → 애플리케이션의 확장과 장애 조치를 처리하고, 배포 패턴 등을 제공함<br/> - 쿠버네티스는 컨테이너 수준에서 운영됨 → Paas가 일반적으로 제공하는 배포, 스케일링, 로드밸런싱과 같은 기능을 제공<br/> - 사용자가 로킹, 모니터링, 알람 솔루션을 통합할 수 있음 → 쿠버네티스는 모놀리식(monolithic)이 아니기때문에 이러한 기본 솔루션이 선택적이며, 추가/제거가 용이함
+ 제공하는 기능
  + 서비스 디스커버리(Service discovery) & 로드 밸런싱(Load balancing)<br/> - 쿠버네티스는 DNS를 사용 or 자체 IP 주소를 사용하여 컨테이너를 노출할 수 있음<br/> - 컨테이너에 대한 트래픽이 많으면, 쿠버네티스는 네트워크 트래픽을 로드밸런싱하고 배포함 → 안정적인 배포가 가능함
  + 스토리지 오케스트레이션(Storage orchestration)<br/> - 쿠버네티스를 사용하면 로컬 저장소, 공용 클라우드 공급자 등과 같이 원하는 저장소 시스템을 자동으로 탑재(mount)할 수 있음
  + 자동화된 롤아웃(Rollouts) & 롤백(Rollbacks)<br/> - 쿠버네티스를 사용해 배포된 컨테이너의 원하는 상태를 서술할 수 있으며, 현재 상태를 원하는 상태로 설정한 속도에 따라 변경할 수 있음<br/> - ex) 쿠버네티스를 자동화하여 배포용 새 컨테이너 생성 + 기존 컨테이너 제거 + 모든 리소스를 새 컨테이너에 적용 가능함
  + 자동화된 빈 패킹(Automatic bin packing)<br/> - 컨테이너화된 작업을 실행하는데 사용할 수 있는 쿠버네티스 클러스터 노드를 제공함<br/> - 각 컨테이너가 필요로 하는 CPU & 메모리(RAM)를 쿠버네티스에게 지시함<br/> - 쿠버네티스는 컨테이너를 노드에 맞춰서 리소스를 가장 잘 사용할 수 있도록 함
  + 자동화된 복구(Self-healing)<br/> - 쿠버네티스는 실패한 컨테이너를 다시 시작하고, 컨테이너를 교체하며, ‘사용자 정의 상태 검사’에 응하지 않는 컨테이너를 죽임 → 서비스 준비가 끝날 때까지 이러한 과정을 클라이언트에 보여주지 않음
  + 암호와 구성 관리(configration management)<br/> - OAuth 토큰 & SSH 키와 같은 중요한 정보를 저장/관리 가능함<br/> - 컨테이너 이미지를 재구성하지 않고 스택 구성에 시크릿을 노출하지 않고도 암호 및 애플리케이션 구성을 배포/업데이트 가능함
+ ***\*What Kubernetes is not\****
  + 지원하는 애플리케이션 유형에 제약이 X
  + 소스코드 배포 X, 애플리케이션 빌드 X
  + 애플리케이션 레벨의 서비스를 제공 X
  + 애플리케이션 레빌의 서비스 : 미들웨어(ex. 메세지 버스), 데이터 처리 프레임워크(ex. Spark), DB(ex. MySQL), 캐시 or 클러스터 스토리지 시스템(ex. Ceph), ...
  + 로킹, 모니터링, 알람 솔루션 포함 X
  + 기본 설정 언어/시스템을 제공 or 요구 X
  + 포괄적인 머신 설정, 유지보수, 관리, 자동 복구 시스템을 제공 or 채택 X
  + 쿠버네티스는 단순한 오케스트레이션 시스템이 X

<br/><br/>

[참고] https://kubernetes.io/ko/docs