# 3. 데이터 입/출력 구현

## Section 031. 데이터 모델의 개념

1. **데이터** **모델** : 현실 세계의 정보들을 컴퓨터에 표현하기 위해서 단순화, 추상화하여 체계적으로 표현한 개념적 모형
2. **데이터** **모델의** **구성** **요소**
   + **개체(Entity)** : DB에 표현하려는 것. 사람이 생각하는 개념이나 정보 단위 같은 현실 세계의 대상체
   + **속성(Attribute)** : 데이터의 가장 작은 논리적 단위. 파일 구조상의 데이터 항목 or 데이터 필드에 해당함
   + **관계(Relationship)** : 개체 간의 관계 or 속성 간의 논리적인 연결을 의미
3. **개념적** **데이터** **모델** : 현실 세계에 대한 인간의 이해를 돕기 위해 현실 세계에 대한 인식을 추상적 개념으로 표현하는 과정
4. **논리적** **데이터** **모델** : 개념적 모델링 과정에서 얻은 개념적 구조를 컴퓨터가 이해하고 처리할 수 있는 컴퓨터 세계의 환경에 맞도록 변환하는 과정
5. **논리적** **데이터** **모델의** **품질** **검증**
   + 개체 품질 검증 항목 - 단수 명사 여부 / 개체의 주 식별자 / 개체 간 상호 배타성 / 개체의 정규화 여부 / 개체 상세 정의 / 개체 관리 업무 기능 / 개체에 2개 이상의 속성 존재 여부 / 개체의 총 길이 / 개체 동의어 여부 / 개체 분산 요구 / ...
   + 속성 품질 검증 항목 - 단수 명사 여부 / 속성의 값 존재 여부 및 개수 / 도메인 정의 / 반복되는 속성 / 그룹화 가능 속성 / 주 식별자 및 비 식별자에 의존하는 속성 / 다치 종속 속성 / …
   + 관계 품질 검증 항목 - 관계의 명칭 / 2개 이상의 노드와 관계 존재 여부 / 노드의 기수성과 선택성 / 필수적 관계 / 유효한 관계 / 중복된 관계 / 외부식별자 존재 여부 / 참조 무결성 여부 / ...
   + 식별자 품질 검증 항목 - 식별자의 명칭 / 정의 / 구성 / 정합성 / 크기 / 순서 / …
   + 전반적인 품질 검증 항목 - 주제 영역 구성의 적절성 / 데이터 모델 상에 정규화 여부 / 다대다 관계 해소 여부 / 이력 관리 대상 선정 확인 / 이력 관리 방법의 적절성 확인
6. **데이터** **모델에** **표시할** **요소**
   + **구조(Structure)** : 논리적으로 표현된 개체 타입들 간의 관계. 데이터 구조 및 정적 성질을 표현
   + **연산(Operation)** : DB에 저장된 실제 데이터를 처리하는 작업에 대한 명세. DB를 조작하는 기본 도구
   + **제약 조건(Constraint)** : DB에 저장될 수 있는 실제 데이터의 논리적인 제약 조건

<br/><br/>

## Section 032. 이상 / 함수적 종속 / 정규화

1. **이상** : 테이블에서 일부 속성들의 종속으로 인해 데이터의 중복이 발생하고, 이 중복(Redundancy)으로 인해 테이블 조작 시 문제가 발생하는 현상을 의미함

   + 삽입 이상(Insertion Anomaly) : 테이블에 데이터를 삽입할 때 의도와는 상관없이 원하지 않은 값들로 인해 삽입할 수 없게 되는 현상
   + 삭제 이상(Deletion Anomaly) : 테이블에서 한 튜플을 삭제할 때 의도와는 상관없는 값들도 함께 삭제되는, 즉 연쇄 삭제가 발생하는 현상임
   + 갱신 이상(Update Anomaly) : 테이블에서 튜플에 있는 속성 값을 갱신할 때 일부 튜플의 정보만 갱신되어 정보에 불일치성(Inconsistency)이 생기는 현상

2. **함수적 종속(Functional Dependency)**

   + 함수적 종속 : 어떤 테이블 R에서 X와 Y를 R의 속성 집합의 부분 집합이라 하자. 속성 X의 값 각각에 대해 시간에 관계없이 항상 속성 Y의 값이 오직 하나만 연관되어 있을 때 Y는 X에 함수적 종속 또는 X가 Y를 함수적으로 결정한다고 하고, **X -> Y** 로 표기함
     + X -> Y의 관계를 갖는 속성 X와 Y에서, **X** : 결정자(Determinant), **Y** : 종속자(Dependent)
     + **완전** **함수적** **종속** : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속이면서 속성 집합 X의 어떠한 진부분 집합 Z(즉, Z X)에서도 함수적 종속이 아닐 때 속성 Y는 속성 집합 X에 완전 함수적 종속이라고 함
     + **부분** **함수적** **종속** : 어떤 테이블 R에서 속성 Y가 다른 속성 집합 X 전체에 대해 함수적 종속 이면서 속성 집합 X의 임의의 진부분 집합에 대해 함수적 종속일 때, 속성 Y는 속성 집합 X에 부분 함수적 종속이라고 함

3. **정규화(Normalization)** : 테이블의 속성들이 상호 종속적인 관계를 갖는 특성을 이용하여 테이블을 무손실 분해하는 과정

4. **정규화 과정**

   1. **제** **1정규형** : 테이블 R에 속한 모든 속성의 도메인(Domain)이 원자 값(Atomic Value)만으로 되어 있는 정규형

   2. **제** **2정규형** : 테이블 R이 제 1정규형이고, 기본키가 아닌 모든 속성이 기본키에 대해 완전 함수적 종속을 만족하는 정규형

   3. **제** **3정규형** : 테이블 R이 제 2정규형이고, 기본키가 아닌 모든 속성이 기본키에 대해 이행적 함수적 종속(Transitive Functional Dependency)을 만족하지 않는 정규형

   4. **BCNF** : 테이블 R에서 모든 결정자가 후보키(Candidate Key)인 정규형

   5. **제** **4정규형** : 테이블 R에 다중 값 종속(MVD: Multi Valued Dependency) A ->-> B가 존재할 경우 R의 모든 속성이 A에 함수적 종속 관계를 만족하는 정규형<br/>

       \* **다중 값 종속(=다치종속)** : A, B, C 3개의 속성을 가진 테이블 R에서 어떤 복합 속성(A, C)에 대응하는 B 값의 집합이 A 값에만 종속되고 C 값에는 무관하면, B는 A에 다중 값 종속이라 함. A ->-> B로 표기

   6. **제** **5정규형** : 테이블 R의 모든 조인 종속(JD: Join Dependency)이 R의 후보키를 통해서만 성립되는 정규형<br/> \* **조인** **종속** : 어떤 테이블 R의 속성에 대한 부분 집합 X, Y, …, Z가 있다고 하자. 이때 만일 테이블 R이 자신의 프로젝션(Projection) X, Y, …, Z를 모두 조인한 결과와 동일한 경우 테이블 R은 조인 종속 JD(X, Y, …, Z)를 만족한다고 함

<br/><br/>

## Section 033. 논리 데이터 모델의 물리 데이터 모델로 전환

1. 엔티티(Entity)를 테이블로 전환
2. 슈퍼타입/서브타입을 테이블로 전환
3. 속성을 컬럼으로 변환
4. 관계를 외래키로 변환
5. 관리 목적의 테이블/컬럼 추가
6. 데이터 타입 선택

<br/><br/>

## Section 034. 반정규화(Denormalization)

1. **반정규화** : 시스템의 성능 향상, 개발 및 운영의 편의성 등을 위해 정규화된 데이터 모델을 통합, 중복, 분리하는 과정. 의도적으로 정규화 원칙을 위배하는 행위
2. **테이블** **통합** : 2개의 테이블이 조인(Join)되는 경우가 많아 하나의 테이블로 합쳐 사용하는 것이 성능 향상에 도움이 될 경우 수행함
3. **테이블** **분할** : 테이블을 수직 or 수평으로 분할하는 것
   + 수평 분할(Horizontal Partitioning) : 레코드(Record)를 기준으로 테이블을 분할하는 것
   + 수직 분할(Vertical Partitioning) : 하나의 테이블에 속성이 너무 많을 경우 속성을 기준으로 테이블을 분할하는 것
4. **중복** **테이블** **추가** : 여러 테이블에서 데이터를 추출해서 사용 or 다른 서버에 저장된 테이블을 이용해야 하는 경우 중복 테이블을 추가하여 작업의 효율성을 향상시킴
5. **중복** **속성** **추가** : 조인해서 데이터를 처리할 때 데이터를 조회하는 경로를 단축하기 위해 자주 사용하는 속성을 하나 더 추가하는 것

<br/><br/>

## **Section 035.** **인덱스** **설계**

1. **인덱스** : 데이터 레코드를 빠르게 접근하기 위해 <키 값, 포인터> 쌍으로 구성되는 데이터 구조
   + 기본 인덱스 : 기본키를 위한 인덱스 / 보조 인덱스 : 기본 인덱스가 아닌 인덱스
   + 클러스터드(Clustered) 인덱스 : 레코드의 물리적 순서가 인덱스의 엔트리 순서와 일치하게 유지되도록 구성되는 인덱스
   + 넌클러스터드(Non-Clustered) 인덱스 : 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
2. **트리** **기반** **인덱스** : 인덱스를 저장하는 블록들이 트리 구조를 이루고 있는 것
   + B 트리 인덱스
   + B+ 트리 인덱스
3. **비트맵** **인덱스** : 인덱스 컬럼의 데이터를 bit 값인 0 or 1로 변환하여 인덱스 키로 사용하는 방법
4. **함수** **기반** **인덱스** : 컬럼의 값 대신 컬럼에 특정 함수(Function)나 수식(Expression)을 적용하여 산출된 값을 사용하는 것. B+ 트리 인덱스 or 비트맵 인덱스를 생성해 사용함
5. **비트맵** **조인** **인덱스** : 다수의 조인된 객체로 구성된 인덱스
6. **도메인** **인덱스(=확장형 인덱스(Extensible Index))** : 개발자가 필요한 인덱스를 직접 만들어 사용하는 것
7. 인덱스 설계 순서
   1. 인덱스의 대상 테이블/컬럼 등을 선정함
   2. 인덱스의 효율성을 검토하여 인덱스 최적화를 수행함
   3. 인덱스 정의서를 작성함
8. **인덱스** **대상** **테이블** **선정** **기준**
   + MULTI BLOCK READ 수에 따라 판단
   + 랜덤 액세스가 빈번한 테이블
   + 특정 범위나 특정 순서로 데이터 조회가 필요한 테이블
   + 다른 테이블과 순차적 조인이 발생되는 테이블

<br/><br/>

## **Section 036.** **뷰** **설계**

1. **뷰** : 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된, 이름을 가지는 가상 테이블
2. 특징
   + 기본 테이블로부터 유도된 테이블임 -> 기본 테이블과 같은 형태의 구조를 사용함
   + 조작도 기본 테이블과 거의 같음뷰는 가상 테이블이기 때문에 물리적으로 구현되어 있지 않음
   + 데이터의 논리적 독립성을 제공할 수 있음
3. **뷰(View)의 장/단점**
   + 장점
     + 논리적 데이터 독립성을 제공함
     + 동일 데이터에 대해 동시에 여러 사용자의 상이한 응용/요구를 지원해줌
     + 사용자의 데이터 관리를 간단하게 해줌
   + 단점
     + 독립적인 인덱스를 가질 수 없음
     + 뷰의 정의를 변경할 수 없음
     + 뷰로 구성된 내용에 대한 삽입, 삭제, 갱신 연산에 제약이 따름
4. **뷰** **설계** **순서**
   1. 대상 테이블 선정
   2. 대상 컬럼 선정
   3. 정의서 작성

<br/><br/>

## **Section 037.** **클러스터** **설계**

1. **클러스터** : 데이터 저장 시 데이터 액세스 효율을 향상시키기 위해 동일한 성격의 데이터를 동일한 데이터 블록에 저장하는 물리적 저장 방법
   + **클러스터링키** : 클러스터링된 테이블에서 각각의 행을 접근할 때 기준이 되는 열. 데이터를 조회하면 클러스터링키로 지정된 필드에서 시작하여 클러스터링된 테이블의 데이터를 조회함
2. 특징
   + 클러스터링된 테이블은 데이터 조회 속도는 향상됨. 데이터 입력/수정/삭제에 대한 성능은 저하됨
   + 데이터의 분포도가 넓을수록 유리함데이터 분포도가 넓은 테이블을 클러스터링 하면 저장 공간이 절약됨
3. 클러스터 대상 테이블
   + 분포도가 넓은 테이블
   + 대량의 범위를 자주 조회하는 테이블
   + 입력/수정/삭제가 자주 발생 안하는 테이블
   + 자주 조인되어 사용되는 테이블
   + OREDER BY, GROUP BY, UNION이 빈번한 테이블

<br/><br/>

## **Section 038.** **파티션** **설계**

1. **파티션** : 대용량의 테이블/인덱스를 작은 논리적 단위인 파티션으로 나누는 것
2. **파티션의** **장/단점**
   + 장점
     + 데이터 접근 시 액세스 범위를 줄여 쿼리 성능이 향상됨
     + 파티션별로 데이터가 분산되어 저장됨 -> 디스크 성능 향상됨
     + 파티션별로 백업/복구를 수행함 -> 속도가 빠름
   + 단점
     + 하나의 테이블을 세분화하여 관리함 -> 세심한 관리가 요구됨
     + 테이블간 조인에 대한 비용이 증가함
3. 종류
   + 범위 분할(Range Partitioning) : 지정한 열의 값을 기준으로 분할함
   + 해시 분할(Hash Partitioning) : 해시 함수를 적용한 결과 값에 따라 데이터를 분할함
   + 조합 분할(Composite Partitioning) : 범위 분할로 분할한 다음 해시 함수를 적용하여 다시 분할하는 방식
4. 파티션 선정 시 고려사항
   + 파티션키는 테이블 접근 유형에 따라 파티셔닝이 이뤄지도록 선정함
   + 데이터 관리의 용이성을 위해 이력성 데이터는 파티션 생성주기와 소멸주기를 일치시켜야 함
5. **인덱스** **파티션** : 파티션된 테이블의 데이터를 관리하기 위해 인덱스를 나눈 것
   + 파티션된 테이블 종속 여부에 따라
     + Local Partitioned Index : 테이블 파티션과 인덱스 파티션이 1:1 대응되도록 파티셔닝
     + Global Partitioned Index : 테이블 파티션과 인덱스 파티션이 독립적으로 구성되도록 파티셔닝함
   + 인텍스 파티션키 컬럼의 위치에 따라
     + Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 같음
     + Non-Prefixed Partitioned Index : 인덱스 파티션키와 인덱스 첫 번째 컬럼이 다름

